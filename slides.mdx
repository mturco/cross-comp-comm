import { Notes } from 'mdx-deck';
import { aspect, prism } from 'mdx-deck/themes';
import { custom } from './theme';
import {
  Name,
  Pattern,
  Patterns,
  PatternsSummary,
  FiltersOpen,
  FiltersClosed
} from './components';

export const themes = [aspect, prism, custom];

export const patterns = [
  {
    title: 'App Level Contexts',
    desc:
      'Using context to provide common data at the application level'
  },
  {
    title: 'Compound Component Contexts',
    desc:
      'Using context to communicate between compound components'
  },
  {
    title: 'Refs with Instance Data',
    desc: 'Using refs to pass instance methods and properties'
  },
  {
    title: 'Dispatch Contexts',
    desc:
      'Using context and useReducer for dependency-agnostic flux'
  }
];

<svg
  width="150"
  height="150"
  viewBox="0 0 167 155"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M90.169 41.094c-.743-.887-1.557-1.99-2.391-2.81-3.015-3.025-5.838-4.773-9.777-6.481-3.895-1.704-8.09-2.567-12.477-2.567-6.467 0-12.322 1.714-17.65 5.129-5.327 3.415-9.29 8.043-11.909 13.865L0 128.204 57.669 155l19.287-40.61c.75.941 1.586 2.175 2.463 3.035 3.015 3.025 5.685 4.561 9.684 6.255 4.034 1.728 8.242 2.575 12.669 2.575 6.423 0 12.208-1.748 17.334-5.278 5.143-3.509 9.085-8.181 11.909-14.002l35.895-79.927L109.483.356 90.169 41.094z"
    fill="#006dd4"
    fillRule="evenodd"
  />
</svg>

# Cross Component Communication

---

# About Me

<Name>Matt Turco</Name>
<div>Frontend Engineer at Namely</div>
<Notes>
  Hi everyone, my name is Matt Turco and I'm a frontend engineer
  here at Namely
  <hr />
  I work on our frontend core team with 5 other engineers
  <hr />
  Our job is to establish the platform on which Namely builds
  applications and features
  <hr />
  1. Setting opinionated best practices
  <hr />
  2. Building design system components
  <hr />
  3. Developing the most important or complicated areas of the
  product
  <hr />
  4. Acting as consultants for any other frontend work going on
</Notes>

---

<svg
  width="150"
  height="150"
  viewBox="0 0 167 155"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M90.169 41.094c-.743-.887-1.557-1.99-2.391-2.81-3.015-3.025-5.838-4.773-9.777-6.481-3.895-1.704-8.09-2.567-12.477-2.567-6.467 0-12.322 1.714-17.65 5.129-5.327 3.415-9.29 8.043-11.909 13.865L0 128.204 57.669 155l19.287-40.61c.75.941 1.586 2.175 2.463 3.035 3.015 3.025 5.685 4.561 9.684 6.255 4.034 1.728 8.242 2.575 12.669 2.575 6.423 0 12.208-1.748 17.334-5.278 5.143-3.509 9.085-8.181 11.909-14.002l35.895-79.927L109.483.356 90.169 41.094z"
    fill="#006dd4"
    fillRule="evenodd"
  />
</svg>

# Cross Component Communication

<Notes>
  So today I'm going to be talking about cross component
  communication
  <hr />
  Or really just how components talk to each other
  <hr />
  React provides us with a number of APIs for communicating
  between components
  <hr />
  Each of those APIs have their own specific use cases but also
  their own shortcomings
  <hr />
  At Namely, we've encountered some of these shortcomings while
  developings of some of our more complicated design system
  components
  <hr />
  So I thought I'd share today some of the issues we've
  encountered and the patterns we created to work around them
</Notes>

---

# Let's review our options

<Notes>
  But first, let's quickly review the options React has given us
  for passing data between components
  <hr />
  Just so we're all on the same page
</Notes>

---

## 1. Props

```jsx
<Greeting subject="World" />
// ↓
<p>Hello, {subject}!</p>
```

<Notes>
  Props are the simplest way to pass data between components in
  React and really most frontend frameworks
  <hr />
  They should be the first option we reach for because they
  introduce the least complexity
  <hr />
  Keeping complexity low is important because it keeps code
  understandable, debuggable, and testable
</Notes>

---

## 2. Render Props

```jsx
// React Router
<Route path="/home" render={() => <h1>Home</h1>} />

// React PowerPlug
<Toggle initial={false}>
  {({ on, toggle }) => (
    <Checkbox onClick={toggle} checked={on} />
  )}
</Toggle>
```

<Notes>
  Another option we have for passing data between components is
  render props
  <hr />
  Render props are simply function props that return JSX for the
  component to render
  <hr />
  2 examples here from popular React libraries
  <hr />
  React Router uses a render prop in its Route component to
  determine what to display is a given path is matched
  <hr />
  React PowerPlug also uses a render prop in its Toggle component
  but instead of using a prop literally called render, it's using
  the children prop because of the special syntax children has in
  React
  <hr />
  This is actually probably the most common way render props are
  used
</Notes>

---

## 3. Refs

```jsx
const ref = useRef();

useEffect(() => {
  ref.current.focus();
}, []);

return <Input ref={ref} />;
```

<Notes>
  Refs allow us to the access DOM nodes that React renders to the
  browser
  <hr />
  This can be useful to do things like focus management, getting
  an element's dimesions, or directly manipulating the DOM
  <hr />
  Refs can also be used for many other things though
  <hr />
  In functional components they can be used as essentially
  instance variables
  <hr />
  But they can also be used to pass data between components which
  we'll revisit later
</Notes>

---

## 4. Context

```jsx
<ThemeContext.Provider value={theme}>
  ...
    <Button />
```

```jsx
const Button = props => {
  const theme = useContext(ThemeContext);
  return <button {...props} className={theme} />;
};
```

<Notes>
  Lastly, we have context
  <hr />
  Context works by passing a value to a provider component
  <hr />
  Any component rendered under this provider in the component
  tree can then subscribe to this value using the useContext hook
  <hr />
  One of the most common use case examples given is for passing
  theming data to components that then customize their appearance
  <hr />
  As we'll see in the next few minutes, context is extremely
  powerful and can simplify component communication in a lot of
  scenarios
</Notes>

---

# We have some good options

1. Props
2. Render Props
3. Refs
4. Context

...but sometimes things still get messy

<Notes>
  So we have some good options for passing data around in our
  applications
  <hr />
  But things can still sometimes get messy
  <hr />
  We can find ourselves prop drilling, creating awkward
  abstractions, or just generally writing components that are
  hard to test
  <hr />
  So let's look at some patterns to help avoid these issues
</Notes>

---

# Useful Patterns

<Patterns active={1} patterns={patterns} />

---

### Problem: Prop drilling

```jsx
<App userName="Michael Scott" />
// ↓
<Dashboard userName={userName} />
// ↓
<DashboardHeader userName={userName} />
// ↓
<UserGreeting userName={userName} />
// ↓
<p>Welcome back, {userName}!</p>
```

<Notes>
  Sometimes we need to pass data down through several layers of
  components in our application
  <hr />
  If we did this using props, we'd need to add a prop to every
  component in the tree all the way down to the actual consumer
  <hr />
  This is often referred to as "prop drilling" and, while it
  works, it has some downsides
  <hr />
  Redundant code
  <hr />
  API changes are noisy
  <hr />
  Separation of concerns (prop-drilled components take props they
  themselves may not care about)
</Notes>

---

### Solution: Use context

```jsx
const UserContext = React.createContext(null);
```

```jsx
<UserContext.Provider value={user}>
  <App>
    <Dashboard>
      <DashboardHeader>
        <UserGreeting />
        ...
```

<Notes>
  One way to solve this is by using context
  <hr />
  If many parts of our application need to access data about the
  user, it might make sense to pass the user data to a context
  provider at the root app level
  <hr />
  As you can see, we're now only passing the data once to the
  provider instead of repeating it at every level
  <hr />
  And any component that needs access to the user's name can
  individually choose to consume that information
</Notes>

---

### Solution: Use context (cont)

```jsx
const UserGreeting = () => {
  const user = useContext(UserContext);
  return <p>Welcome back, {user.name}!</p>;
};
```

<Notes>
  If we take a look at the UserGreeting component we see that
  it's simply consuming the UserContext we defined on the
  previous slide
  <hr />
  There is one thing worth calling out here though. One of the
  benefits of functional components in React is that they are
  inherently pure functions, meaning that given the same input,
  they always return the same output.
  <hr />
  That becomes no longer true for this component now that it's
  consuming our user context. That's not necessarily a bad thing
  but it does make this component slightly more complex.
  <hr />
  It's worth pointing out that we probably don't want to connect
  many simple presentation components to context like this. If we
  do have a situation where that would be necessary, it might be
  better to have a parent component that consumes the context and
  passes the data down to these presentational components.
</Notes>

---

# Useful Patterns

<Patterns active={2} patterns={patterns} />

---

### Problem: Repeated props

```jsx
<RadioButton name="color" value="red" checked={color === 'red'} />
<RadioButton name="color" value="green" checked={color === 'green'} />
<RadioButton name="color" value="blue" checked={color === 'blue'} />
<RadioButton name="color" value="yellow" checked={color === 'yellow'} />
<RadioButton name="color" value="purple" checked={color === 'purple'} />
<RadioButton name="color" value="orange" checked={color === 'orange'} />
```

The only distinct data here is each radio's `value`

<Notes>
  So how many of you have seen code that looks like this before?
  I'd be willing to bet most of us have
  <hr />
  The way native radio buttons work requires that we repeat the
  group name "color" for each radio button
  <hr />
  Worse than that is the fact that the logic for the checked prop
  is being repeated for each radio button as well
  <hr />
  So what do we do about this?
</Notes>

---

### Solution: RadioGroup component that uses context

```jsx
<RadioGroup name="color" selectedValue={color}>
  <RadioButton value="red" />
  <RadioButton value="green" />
  <RadioButton value="blue" />
  <RadioButton value="yellow" />
  <RadioButton value="purple" />
  <RadioButton value="orange" />
</RadioGroup>
```

Now all common data is passed to `RadioGroup`

<Notes>
  One solution would be to introduce a RadioGroup component that
  takes name and selectedValue props and passes them down to our
  RadioButton components via context
  <hr />
  This abstracts the data and logic that the radio buttons had in
  common in a single place
  <hr />
  The group name and the currently selected value are now passed
  only once to RadioGroup
</Notes>

---

### Solution: RadioGroup component that uses context (cont)

```jsx
const RadioGroup = ({ children, name, selectedValue }) => {
  const context = useMemo(() => ({ name, selectedValue }), [
    name,
    selectedValue
  ]);

  return (
    <RadioGroupContext.Provider value={context}>
      {children}
    </RadioGroupContext>
  );
};
```

<Notes>
  If we take a look at the RadioGroup component, we see that it's
  not doing much internally
  <hr />
  Essentially it's just forwardng the data along in a context
  provider
  <hr />
  Note that we're using useMemo here to avoid creating a new
  object instance on every render
</Notes>

---

### Solution: RadioGroup component that uses context (cont)

```jsx
const RadioButton = ({ value }) => {
  const { name, selectedValue } = useContext(RadioGroupContext);

  return (
    <input
      type="radio"
      name={name}
      value={value}
      checked={value === selectedValue}
    />
  );
};
```

<Notes>
  Next let's take a look at the RadioButton component
  <hr />
  It's also very simple
  <hr />
  It's essentially just pulling out the name and selected value
  from the radio group context and using them to render the radio
  button
  <hr />
  Note that we're excluding the change event handler from the
  code example to keep it short
  <hr />
  So here's an example of context cleaning up the API of a
  compound component while keeping the implementation very simple
  and easy to follow
</Notes>

---

### Taking it a step further

```jsx
<SelectionGroup name="sizes" selectedValue={sizes}>
  <Checkbox value="small" />
  <Checkbox value="medium" />
  <Checkbox value="large" />
</SelectionGroup>
```

<Notes>
  The nice thing about this abstraction is that it is super
  reusable
  <hr />
  In this example, we could rename RadioGroup to SelectionGroup
  and allow it to be used with checkboxes as well
  <hr />
  With a slightly different change event handler, this code could
  work without any API changes
  <hr />
  At Namely, we've taken this idea and run with it a bit. In
  fact, we took this same pattern and used it to handle form
  state management for us.
</Notes>

---

# Useful Patterns

<Patterns active={3} patterns={patterns} />

---

### Problem: Data provided by render props has a limited scope

```jsx
<Form>
  {({ values, handleChange }) => (
    <>
      <input
        name="name"
        value={values.name}
        onChange={handleChange}
      />
      <input
        name="email"
        value={values.email}
        onChange={handleChange}
      />
      <button type="submit">Submit</button>
    </>
  )}
</Form>
```

<Notes>
  Imagine that we have a Form component that not only renders an
  HTML form but also does some state management for us
  <hr />
  It's children prop is a render prop that passes us the form
  state and a change event handler function
  <hr />
  So you can see here we have values which contains our form
  state and we're using that to set the values of these 2 inputs
  <hr />
  There's also this handleChange function that's automatically
  updating our state whenever a change event happens
  <hr />
  This seems to be working fine but what if we needed to access
  the form state data from outside of this form component?
</Notes>

---

### Problem: Data provided by render props has a limited scope (cont)

<!-- prettier-ignore -->
```jsx
const AutoSaveForm = ({ save }) => {
  // Oops! We don't have access to `values` from here
  useTimeInterval(15000, () => save(values));

  return (
    <Form>
      {({ values, handleChange }) => <>...</>}
    </Form>
  );
};
```

<Notes>
  For example, let's imagine we had this AutoSaveForm component
  that used our Form component internally
  <hr />
  It needs access to the form state so it can send it to an API
  every 15 seconds
  <hr />
  Unfortunately this wouldn't work because we don't have access
  to the values variable outside of the render prop function
</Notes>

---

### Solution: Provide instance methods or properties using a ref

```jsx
const Form = forwardRef(({ children }, forwardedRef) => {
  const ref = useRef();
  const [state, setState] = useState({});

  useImperativeHandle(forwardedRef, () => ({
    element: ref.current,
    values: state
  }));

  return children({
    values: state,
    handleChange: evt =>
      setState({ [evt.target.name]: evt.target.value })
  });
});
```

<Notes>
  One way to work around this scope issue is by updating our Form
  component to attach an instance property to its ref
  <hr />
  So you can see here we're using React's useImperativeHandle
  hook to customize the ref value before forwarding it to
  consumers.
  <hr />
  We keep the reference to the DOM node and assign that to the
  element property just in case any consumers need it.
  <hr />
  Then we add a values property that contains the form state
  <hr />
  Also note that we're passing an object literal to the children
  prop here which is something you should never do in real code.
  This will cause React to always rerender this component because
  the argument passed to children will never be a reference to
  the object. We could fix this by wrapping the object in useMemo
  first. So bonus points to anyone who caught that.
</Notes>

---

### Solution: Provide instance methods or properties using a ref (cont)

```jsx
const AutoSaveForm = ({ save }) => {
  const form = useRef();

  useTimeInterval(15000, () => save(form.current.values));

  return (
    <Form ref={form}>
      {({ values, handleChange }) => <>...</>}
    </Form>
  );
};
```

<Notes>
  Now we can update AutoSaveForm to use the instance property we
  attached to the ref in this useTimeInterval hook
  <hr />
  We do this by creating a ref, assigning it to the form
  component, and then accessing the ref's values property
</Notes>

---

# Useful Patterns

<Patterns active={4} patterns={patterns} />

---

### Problem: Complex compound component with a lot of intercommunication

<FiltersOpen />
<FiltersClosed />
<Notes>
  At Namely one of the design system components we worked on
  recently was a Filters dropdown. The dropdown contains a
  dynamic number of filter fields, a reset button, and an apply
  button (so it's basically a mini form in a dropdown). Hitting
  Apply not only filters the content but also causes these little
  filter chips to be rendered.
  <hr />
  So there's a lot of intercommunication going on in this
  component. Data is being shared between a lot of different
  components and then rendered in several different places, and
  various parts of the component need to handle events.
  <hr />
  We could solve this by using a bunch of callback props that
  then get prop drilled but there's a much cleaner solution using
  context.
</Notes>

---

### Solution: Use context to pass a dispatch function

```jsx
const FiltersContext = React.createContext();

const Filters = () => {
  const [state, dispatch] = useReducer(filtersReducer);

  return (
    <FiltersContext.Provider value={dispatch}>
      ...
    </FiltersContext.Provider>
  );
};
```

<Notes>
  First we use React's useReducer hook and pass the dispatch
  function to a context provider in the top-level component.
</Notes>

---

### Solution: Use context to pass a dispatch function (cont)

```jsx
const FiltersToggle = () => {
  const dispatch = useContext(FiltersContext);
  const handleClick = useCallback(
    () => dispatch({ type: 'TOGGLE_DROPDOWN' }),
    [dispatch]
  );

  return <button onClick={handleClick}>Filters</button>;
};
```

<Notes>
  Then, in any subcomponent that needs to dispatch an action, we
  consume the FiltersContext to get access to the dispatch
  function, and call it from any event handlers we need to.
  <hr />
  In this example we're dispatching a TOGGLE_DROPDOWN action from
  the main dropdown menu button component to open or close the
  dropdown.
  <hr />
  By sharing this dispatch function via context, we're able to
  utilize the flux pattern which is great at grouping state
  change logic in a single place
</Notes>

---

# Useful Patterns

<PatternsSummary patterns={patterns} />
<Notes>
  So we've gone over 4 different patterns we've started using in
  our more complicated components at Namely. Hopefully something
  I talked about today can help clean up the APIs of some of your
  components or just give you another option for communicating
  between your components.
</Notes>

---

<svg
  width="150"
  height="150"
  viewBox="0 0 167 155"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M90.169 41.094c-.743-.887-1.557-1.99-2.391-2.81-3.015-3.025-5.838-4.773-9.777-6.481-3.895-1.704-8.09-2.567-12.477-2.567-6.467 0-12.322 1.714-17.65 5.129-5.327 3.415-9.29 8.043-11.909 13.865L0 128.204 57.669 155l19.287-40.61c.75.941 1.586 2.175 2.463 3.035 3.015 3.025 5.685 4.561 9.684 6.255 4.034 1.728 8.242 2.575 12.669 2.575 6.423 0 12.208-1.748 17.334-5.278 5.143-3.509 9.085-8.181 11.909-14.002l35.895-79.927L109.483.356 90.169 41.094z"
    fill="#006dd4"
    fillRule="evenodd"
  />
</svg>

# Namely is hiring frontend engineers!

[namely.com/careers](https://www.namely.com/careers/)

<Notes>
  And lastly, as a quick plug, we are currently looking for
  experienced engineers to join our team
  <hr />
  So if any of what I said in this talk sounds interesting or
  exciting to you, make sure to stop by and talk to myself or any
  of the other Namely engineers here tonight
</Notes>

---

# Questions
